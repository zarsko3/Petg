#!/usr/bin/env tsx

import fs from 'fs';
import path from 'path';

// Types for design system schema
interface DesignTokens {
  colors: {
    semantic: Record<string, { light: string; dark: string } | string>;
    brand: Record<string, Record<string, string>>;
    domain: Record<string, Record<string, string>>;
    background: Record<string, string>;
    chart: Record<string, { light: string; dark: string }>;
  };
  spacing: {
    component: Record<string, Record<string, string>>;
    layout: Record<string, string>;
    padding: Record<string, string>;
    margin: Record<string, string>;
  };
  fonts: {
    family: Record<string, string>;
    size: Record<string, string>;
    weight: Record<string, string>;
    lineHeight: Record<string, string>;
  };
  radii: Record<string, string>;
  shadows: Record<string, string>;
  transitions: Record<string, string>;
  breakpoints: Record<string, string>;
}

// Utility functions
const hslToHex = (hsl: string): string => {
  const hslMatch = hsl.match(/(\d+\.?\d*)\s+(\d+\.?\d*)%\s+(\d+\.?\d*)%/);
  if (!hslMatch) return '#000000';
  
  const h = parseInt(hslMatch[1]) / 360;
  const s = parseInt(hslMatch[2]) / 100;
  const l = parseInt(hslMatch[3]) / 100;
  
  const a = s * Math.min(l, 1 - l);
  const f = (n: number) => {
    const k = (n + h * 12) % 12;
    const color = l - a * Math.max(Math.min(k - 3, 9 - k, 1), -1);
    return Math.round(255 * color);
  };
  
  const r = f(0).toString(16).padStart(2, '0');
  const g = f(8).toString(16).padStart(2, '0');
  const b = f(4).toString(16).padStart(2, '0');
  
  return `#${r}${g}${b}`;
};

class DesignSystemSync {
  private tokens: DesignTokens;
  private version: string;

  constructor() {
    this.version = this.getVersion();
    this.tokens = this.loadTokens();
  }

  private getVersion(): string {
    try {
      const packageJson = JSON.parse(fs.readFileSync('package.json', 'utf8'));
      return packageJson.version || '1.0.0';
    } catch {
      return '1.0.0';
    }
  }

  private loadTokens(): DesignTokens {
    const tokensPath = 'packages/ui/design-tokens.json';
    
    if (!fs.existsSync(tokensPath)) {
      throw new Error(`Design tokens file not found at ${tokensPath}`);
    }

    try {
      const tokensContent = fs.readFileSync(tokensPath, 'utf8');
      return JSON.parse(tokensContent);
    } catch (error) {
      throw new Error(`Failed to parse design tokens: ${error}`);
    }
  }

  private validateTokens(): void {
    console.log('üîç Validating design tokens schema...');
    
    const requiredSections = ['colors', 'spacing', 'fonts', 'radii'];
    const missingSections = requiredSections.filter(section => !this.tokens[section as keyof DesignTokens]);
    
    if (missingSections.length > 0) {
      throw new Error(`Missing required token sections: ${missingSections.join(', ')}`);
    }

    console.log('‚úÖ Design tokens schema validation passed');
  }

  private generateNativeTokens(): void {
    console.log('üì± Generating React Native tokens...');

    const colors = this.tokens.colors;
    const nativeColors: Record<string, any> = {};

    // Process semantic colors for light/dark modes
    Object.entries(colors.semantic).forEach(([key, value]) => {
      if (typeof value === 'object' && value.light) {
        nativeColors[key] = {
          light: hslToHex(value.light),
          dark: hslToHex(value.dark),
        };
      }
    });

    // Add brand and domain colors
    Object.entries(colors.brand).forEach(([brand, brandColors]) => {
      nativeColors[brand] = brandColors;
    });

    Object.entries(colors.domain).forEach(([domain, domainColors]) => {
      nativeColors[domain] = domainColors;
    });

    const tokensPath = 'packages/ui/native/tokens.ts';
    const tokensContent = `// Auto-generated design tokens for React Native
// DO NOT EDIT - Generated by sync-design-system.ts

export const designTokens = ${JSON.stringify(this.tokens, null, 2)};

export const getColor = (colorPath: string, mode: 'light' | 'dark' = 'light'): string => {
  const pathParts = colorPath.split('.');
  let current: any = designTokens.colors;
  
  for (const part of pathParts) {
    current = current[part];
    if (!current) return '#000000';
  }
  
  if (typeof current === 'object' && current.light && current.dark) {
    return current[mode];
  }
  
  return typeof current === 'string' ? current : '#000000';
};

export default designTokens;
`;

    // Ensure directory exists
    const dir = path.dirname(tokensPath);
    if (!fs.existsSync(dir)) {
      fs.mkdirSync(dir, { recursive: true });
    }

    fs.writeFileSync(tokensPath, tokensContent);
    console.log('‚úÖ Generated React Native tokens');
  }

  public async sync(): Promise<void> {
    try {
      console.log('üöÄ Starting design system synchronization...\n');

      this.validateTokens();
      this.generateNativeTokens();

      console.log('\n‚úÖ Design system synchronization completed successfully!');

    } catch (error) {
      console.error('‚ùå Design system sync failed:', error);
      process.exit(1);
    }
  }
}

// CLI execution
const syncer = new DesignSystemSync();
syncer.sync(); 